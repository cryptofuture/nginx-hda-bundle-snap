Description: xmmp patch backported from nginx-xmpp (https://github.com/robn/nginx-xmpp)
Author: hda_launchpad (hda_launchpad) <admin@hda.me>
--- nginx-1.10.1-10.orig/src/mail/ngx_mail.h
+++ nginx-1.10.1-10/src/mail/ngx_mail.h
@@ -114,6 +114,7 @@ typedef struct {
 #define NGX_MAIL_POP3_PROTOCOL  0
 #define NGX_MAIL_IMAP_PROTOCOL  1
 #define NGX_MAIL_SMTP_PROTOCOL  2
+#define NGX_MAIL_XMPP_PROTOCOL  3
 
 
 typedef struct ngx_mail_protocol_s  ngx_mail_protocol_t;
@@ -178,6 +179,15 @@ typedef enum {
 } ngx_smtp_state_e;
 
 
+typedef enum {
+    ngx_xmpp_start = 0,
+    ngx_xmpp_stream,
+    ngx_xmpp_auth_login_username,
+    ngx_xmpp_auth_login_password,
+    ngx_xmpp_auth_plain,
+} ngx_xmpp_state_e;
+
+
 typedef struct {
     ngx_peer_connection_t   upstream;
     ngx_buf_t              *buffer;
@@ -293,6 +303,11 @@ typedef struct {
 #define NGX_SMTP_STARTTLS      13
 
 
+#define NGX_XMPP_STREAM        1
+#define NGX_XMPP_STARTTLS      2
+#define NGX_XMPP_AUTH          3
+
+
 #define NGX_MAIL_AUTH_PLAIN             0
 #define NGX_MAIL_AUTH_LOGIN             1
 #define NGX_MAIL_AUTH_LOGIN_USERNAME    2
--- nginx-1.10.1-10.orig/src/mail/ngx_mail_auth_http_module.c
+++ nginx-1.10.1-10/src/mail/ngx_mail_auth_http_module.c
@@ -458,6 +458,14 @@ done:
 }
 
 
+static u_char xmpp_auth_failure_start[] =
+    "<failure xmlns=\"urn:ietf:params:xml:ns:xmpp-sasl\">"
+    "<not-authorized/>"
+    "<text>";
+static u_char xmpp_auth_failure_end[] =
+    "</text>"
+    "</failure>";
+
 static void
 ngx_mail_auth_http_process_headers(ngx_mail_session_t *s,
     ngx_mail_auth_http_ctx_t *ctx)
@@ -536,6 +544,11 @@ ngx_mail_auth_http_process_headers(ngx_m
                            + sizeof(CRLF) - 1;
                     break;
 
+                case NGX_MAIL_XMPP_PROTOCOL:
+                    size = sizeof(xmpp_auth_failure_start) - 1 + len
+                           + sizeof(xmpp_auth_failure_end) - 1;
+                    break;
+
                 default: /* NGX_MAIL_SMTP_PROTOCOL */
                     ctx->err = ctx->errmsg;
                     continue;
@@ -562,12 +575,25 @@ ngx_mail_auth_http_process_headers(ngx_m
                     *p++ = 'N'; *p++ = 'O'; *p++ = ' ';
                     break;
 
+                case NGX_MAIL_XMPP_PROTOCOL:
+                    p = ngx_cpymem(p, xmpp_auth_failure_start, sizeof(xmpp_auth_failure_start) - 1);
+                    break;
+
                 default: /* NGX_MAIL_SMTP_PROTOCOL */
                     break;
                 }
 
                 p = ngx_cpymem(p, ctx->header_start, len);
-                *p++ = CR; *p++ = LF;
+
+                switch (s->protocol) {
+                case NGX_MAIL_XMPP_PROTOCOL:
+                    p = ngx_cpymem(p, xmpp_auth_failure_end, sizeof(xmpp_auth_failure_end) - 1);
+                    break;
+
+                default:
+                    *p++ = CR; *p++ = LF;
+                    break;
+                }
 
                 ctx->err.len = p - ctx->err.data;
 
--- nginx-1.10.1-10.orig/src/mail/ngx_mail_parse.c
+++ nginx-1.10.1-10/src/mail/ngx_mail_parse.c
@@ -12,6 +12,7 @@
 #include <ngx_mail_pop3_module.h>
 #include <ngx_mail_imap_module.h>
 #include <ngx_mail_smtp_module.h>
+#include <ngx_mail_xmpp_module.h>
 
 
 ngx_int_t
@@ -855,6 +856,275 @@ invalid:
 
     return NGX_MAIL_PARSE_INVALID_COMMAND;
 }
+
+
+ngx_int_t
+ngx_mail_xmpp_parse_command(ngx_mail_session_t *s)
+{
+    u_char      ch, *p, *c;
+    ngx_str_t  *arg;
+    enum {
+        sw_start = 0,
+        sw_elem_start,
+        sw_elem,
+        sw_whitspace_between_attrs,
+        sw_attr_name,
+        sw_attr_value_quote_start,
+        sw_attr_value,
+        sw_cdata_start,
+        sw_cdata
+    } state;
+
+    state = s->state;
+
+    for (p = s->buffer->pos; p < s->buffer->last; p++) {
+        ch = *p;
+
+        switch (state) {
+
+        case sw_start:
+            switch (ch) {
+            case '<':
+                state = sw_elem_start;
+                break;
+            }
+            break;
+
+        case sw_elem_start:
+            s->literal_len = 0;
+
+            switch (ch) {
+            case ' ': case CR: case LF:
+                break;
+            default:
+                s->cmd_start = p;
+                state = sw_elem;
+                break;
+            }
+            break;
+
+        case sw_elem:
+            if (ch == ':') {
+                state = sw_elem_start;
+                break;
+            }
+
+            if (ch == ' ' || ch == CR || ch == LF || ch == '>') {
+
+                c = s->cmd_start;
+
+                s->command = 0;
+
+                switch (p - c) {
+                    case 6:
+                        if (c[0] == 's'
+                            && c[1] == 't'
+                            && c[2] == 'r'
+                            && c[3] == 'e'
+                            && c[4] == 'a'
+                            && c[5] == 'm')
+                        {
+                            s->command = NGX_XMPP_STREAM;
+                        }
+                        break;
+
+                    case 8:
+#if (NGX_MAIL_SSL)
+                        if (c[0] == 's'
+                            && c[1] == 't'
+                            && c[2] == 'a'
+                            && c[3] == 'r'
+                            && c[4] == 't'
+                            && c[5] == 't'
+                            && c[6] == 'l'
+                            && c[7] == 's')
+                        {
+                            s->command = NGX_XMPP_STARTTLS;
+                        }
+#endif
+
+                        if (c[0] == 'r'
+                            && c[1] == 'e'
+                            && c[2] == 's'
+                            && c[3] == 'p'
+                            && c[4] == 'o'
+                            && c[5] == 'n'
+                            && c[6] == 's'
+                            && c[7] == 'e')
+                        {
+                            s->command = NGX_XMPP_AUTH;
+                        }
+
+                        break;
+
+                    case 4:
+                        if (c[0] == 'a'
+                            && c[1] == 'u'
+                            && c[2] == 't'
+                            && c[3] == 'h')
+                        {
+                            s->command = NGX_XMPP_AUTH;
+                        }
+                        break;
+
+                }
+
+                switch (ch) {
+                case ' ': case CR: case LF:
+                    state = sw_whitspace_between_attrs;
+                    break;
+                case '>':
+                    if (s->command == NGX_XMPP_AUTH && !s->literal_len) {
+                        state = sw_cdata_start;
+                        break;
+                    }
+                    state = sw_start;
+                    if (s->command) {
+                        goto done;
+                    }
+                    break;
+                }
+            }
+
+            break;
+
+        case sw_whitspace_between_attrs:
+            switch (ch) {
+            case ' ': case CR: case LF:
+                break;
+            case '/': case '?':
+                s->literal_len = 1; // reusing as self-close flag
+                break;
+            case '>':
+                if (s->command == NGX_XMPP_AUTH && !s->literal_len) {
+                    state = sw_cdata_start;
+                    break;
+                }
+                state = sw_start;
+                if (s->command) {
+                    goto done;
+                }
+                break;
+            default:
+                s->arg_start = p;
+                state = sw_attr_name;
+                break;
+            }
+            break;
+
+        case sw_attr_name:
+            if (ch == '=') {
+                s->arg_end = p;
+                state = sw_attr_value_quote_start;
+            }
+            break;
+
+        case sw_attr_value_quote_start:
+            switch (ch) {
+            case '"': case '\'':
+                s->cmd_start = p; // reusing to remember quote type
+                state = sw_attr_value;
+                break;
+            default:
+                goto invalid;
+            }
+            break;
+
+        case sw_attr_value:
+            if (ch != s->cmd_start[0])
+                break;
+
+            c = s->arg_start;
+            if (s->command == NGX_XMPP_STREAM) {
+                if (s->arg_end - c == 2
+                    && c[0] == 't' && c[1] == 'o') {
+
+                    arg = ngx_array_push(&s->args);
+                    if (arg == NULL) {
+                        return NGX_ERROR;
+                    }
+                    arg->len = p - s->arg_end - 2;
+                    arg->data = s->arg_end + 2;
+                }
+            }
+            else if (s->command == NGX_XMPP_AUTH) {
+                if (s->arg_end - c == 9
+                    && c[0] == 'm'
+                    && c[1] == 'e'
+                    && c[2] == 'c'
+                    && c[3] == 'h'
+                    && c[4] == 'a'
+                    && c[5] == 'n'
+                    && c[6] == 'i'
+                    && c[7] == 's'
+                    && c[8] == 'm') {
+
+                    arg = ngx_array_push(&s->args);
+                    if (arg == NULL) {
+                        return NGX_ERROR;
+                    }
+                    arg->len = p - s->arg_end - 2;
+                    arg->data = s->arg_end + 2;
+                }
+            }
+
+            state = sw_whitspace_between_attrs;
+            break;
+
+        case sw_cdata_start:
+            switch (ch) {
+            case '<':
+                state = sw_start;
+                goto done;
+            default:
+                s->arg_start = p;
+                state = sw_cdata;
+                break;
+            }
+            break;
+
+        case sw_cdata:
+            switch (ch) {
+            case '<':
+                if (p - s->arg_start == 0) {
+                    state = sw_start;
+                    goto done;
+                }
+
+                arg = ngx_array_push(&s->args);
+                if (arg == NULL) {
+                    return NGX_ERROR;
+                }
+
+                arg->len = p - s->arg_start;
+                arg->data = s->arg_start;
+
+                state = sw_start;
+                goto done;
+            }
+            break;
+
+        }
+    }
+
+    s->buffer->pos = p;
+    s->state = state;
+
+    return NGX_AGAIN;
+
+done:
+
+    s->buffer->pos = p + 1;
+    s->state = sw_start;
+
+    return NGX_OK;
+
+invalid:
+
+    s->state = sw_start;
+
+    return NGX_MAIL_PARSE_INVALID_COMMAND;
+}
 
 
 ngx_int_t
--- nginx-1.10.1-10.orig/src/mail/ngx_mail_proxy_module.c
+++ nginx-1.10.1-10/src/mail/ngx_mail_proxy_module.c
@@ -25,6 +25,9 @@ static void ngx_mail_proxy_block_read(ng
 static void ngx_mail_proxy_pop3_handler(ngx_event_t *rev);
 static void ngx_mail_proxy_imap_handler(ngx_event_t *rev);
 static void ngx_mail_proxy_smtp_handler(ngx_event_t *rev);
+static void ngx_mail_proxy_xmpp_auth_fixup(ngx_mail_session_t *s);
+static void ngx_mail_proxy_xmpp_write_handler(ngx_event_t *rev);
+static void ngx_mail_proxy_xmpp_read_handler(ngx_event_t *rev);
 static void ngx_mail_proxy_dummy_handler(ngx_event_t *ev);
 static ngx_int_t ngx_mail_proxy_read_response(ngx_mail_session_t *s,
     ngx_uint_t state);
@@ -173,11 +176,28 @@ ngx_mail_proxy_init(ngx_mail_session_t *
         s->mail_state = ngx_imap_start;
         break;
 
+    case NGX_MAIL_XMPP_PROTOCOL:
+        ngx_mail_proxy_xmpp_auth_fixup(s);
+        p->upstream.connection->read->handler = ngx_mail_proxy_xmpp_read_handler;
+        p->upstream.connection->write->handler = ngx_mail_proxy_xmpp_write_handler;
+        s->mail_state = ngx_xmpp_start;
+        break;
+
     default: /* NGX_MAIL_SMTP_PROTOCOL */
         p->upstream.connection->read->handler = ngx_mail_proxy_smtp_handler;
         s->mail_state = ngx_smtp_start;
         break;
     }
+
+    if (s->protocol != NGX_MAIL_XMPP_PROTOCOL)
+        return;
+
+    /* XMPP client sends first */
+    if (rc == NGX_OK) {
+        ngx_mail_proxy_xmpp_write_handler(p->upstream.connection->write);
+        return;
+    }
+
 }
 
 
@@ -697,6 +717,209 @@ ngx_mail_proxy_smtp_handler(ngx_event_t
 }
 
 
+static u_char xmpp_stream_header_stream[] =
+    "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
+    "<stream:stream version=\"1.0\" xmlns:stream=\"http://etherx.jabber.org/streams\" xmlns=\"jabber:client\" to=\"";
+static u_char xmpp_stream_header_stream_end[] =
+    "\">";
+static u_char xmpp_stream_header_auth[] =
+    "<auth mechanism=\"PLAIN\" xmlns=\"urn:ietf:params:xml:ns:xmpp-sasl\">";
+static u_char xmpp_stream_header_auth_end[] =
+    "</auth>";
+
+static void
+ngx_mail_proxy_xmpp_auth_fixup(ngx_mail_session_t *s)
+{
+    u_char *p, *last;
+
+    for (
+        p = s->login.data, last = p + s->login.len;
+        p < last;
+        p++) {
+
+        if (*p == '@') {
+            s->login.len = p - s->login.data;
+            *p++ = 0;
+            s->host.data = p;
+            s->host.len = last - p;
+            return;
+        }
+    }
+}
+
+static void
+ngx_mail_proxy_xmpp_write_handler(ngx_event_t *rev)
+{
+    u_char                 *p;
+    ngx_str_t               line;
+    ngx_str_t               plain, plainb64;
+    ngx_connection_t       *c;
+    ngx_mail_session_t     *s;
+    int                     len;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
+                   "mail proxy xmpp write auth handler");
+
+    c = rev->data;
+    s = c->data;
+
+    if (rev->timedout) {
+        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,
+                      "upstream timed out");
+        c->timedout = 1;
+        ngx_mail_proxy_internal_server_error(s);
+        return;
+    }
+
+    switch (s->mail_state) {
+
+    case ngx_xmpp_start:
+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0, "mail proxy xmpp stream start");
+
+        s->connection->log->action = "starting xmpp stream";
+
+        line.len = sizeof(xmpp_stream_header_stream) - 1
+                    + s->host.len
+                    + sizeof(xmpp_stream_header_stream_end) - 1;
+
+        line.data = ngx_pnalloc(c->pool, line.len);
+        if (line.data == NULL) {
+            ngx_mail_proxy_internal_server_error(s);
+            return;
+        }
+
+        p = ngx_cpymem(line.data, xmpp_stream_header_stream, sizeof(xmpp_stream_header_stream) - 1);
+        p = ngx_cpymem(p, s->host.data, s->host.len);
+        p = ngx_cpymem(p, xmpp_stream_header_stream_end, sizeof(xmpp_stream_header_stream_end) - 1);
+
+        s->mail_state = ngx_xmpp_stream;
+
+        break;
+
+    case ngx_xmpp_auth_plain:
+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0, "mail proxy xmpp auth");
+
+        s->connection->log->action = "starting xmpp auth";
+
+        len = s->login.len + s->passwd.len + 2;
+
+        plainb64.data = ngx_pnalloc(c->pool, ngx_base64_encoded_length(s->login.len + s->passwd.len + 2) + 1);
+        if (plainb64.data == NULL) {
+            ngx_mail_proxy_internal_server_error(s);
+            return;
+        }
+
+        p = ngx_pnalloc(c->pool, len + 1);
+        if (p == NULL) {
+            ngx_mail_proxy_internal_server_error(s);
+            return;
+        }
+
+        plain.data = p;
+        plain.len = len;
+
+        *p++ = '\0';
+        p = ngx_cpymem(p, s->login.data, s->login.len);
+        *p++ = '\0';
+        p = ngx_cpymem(p, s->passwd.data, s->passwd.len);
+
+        ngx_encode_base64(&plainb64, &plain);
+
+        line.len = sizeof(xmpp_stream_header_auth) - 1
+                    + plainb64.len
+                    + sizeof(xmpp_stream_header_auth_end) - 1;
+
+        line.data = ngx_pnalloc(c->pool, line.len);
+        if (line.data == NULL) {
+            ngx_mail_proxy_internal_server_error(s);
+            return;
+        }
+
+        p = ngx_cpymem(line.data, xmpp_stream_header_auth, sizeof(xmpp_stream_header_auth) - 1);
+        p = ngx_cpymem(p, plainb64.data, plainb64.len);
+        p = ngx_cpymem(p, xmpp_stream_header_auth_end, sizeof(xmpp_stream_header_auth_end) - 1);
+
+        s->mail_state = ngx_xmpp_auth_plain;
+
+        break;
+
+    default:
+#if (NGX_SUPPRESS_WARN)
+        ngx_str_null(&line);
+#endif
+        break;
+    }
+
+    if (c->send(c, line.data, line.len) < (ssize_t) line.len) {
+        ngx_close_connection(c);
+        ngx_destroy_pool(c->pool);
+        ngx_mail_proxy_internal_server_error(s);
+        return;
+    }
+}
+
+static void
+ngx_mail_proxy_xmpp_read_handler(ngx_event_t *rev)
+{
+    ngx_int_t               rc;
+    ngx_connection_t       *c;
+    ngx_mail_session_t     *s;
+    ngx_mail_proxy_conf_t  *pcf;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,
+                   "mail proxy xmpp auth handler");
+
+    c = rev->data;
+    s = c->data;
+
+    if (rev->timedout) {
+        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,
+                      "upstream timed out");
+        c->timedout = 1;
+        ngx_mail_proxy_internal_server_error(s);
+        return;
+    }
+
+    rc = ngx_mail_proxy_read_response(s, s->mail_state);
+
+    if (rc == NGX_AGAIN) {
+        return;
+    }
+
+    if (rc == NGX_ERROR) {
+        ngx_mail_proxy_upstream_error(s);
+        return;
+    }
+
+    switch (s->mail_state) {
+
+    case ngx_xmpp_stream:
+        s->mail_state = ngx_xmpp_auth_plain;
+        break;
+
+    case ngx_xmpp_auth_plain:
+        s->connection->read->handler = ngx_mail_proxy_handler;
+        s->connection->write->handler = ngx_mail_proxy_handler;
+        rev->handler = ngx_mail_proxy_handler;
+        c->write->handler = ngx_mail_proxy_handler;
+
+        pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);
+        ngx_add_timer(s->connection->read, pcf->timeout);
+        ngx_del_timer(c->read);
+
+        c->log->action = NULL;
+        ngx_log_error(NGX_LOG_INFO, c->log, 0, "client logged in");
+
+        ngx_mail_proxy_handler(s->connection->write);
+
+        break;
+    }
+
+    s->proxy->buffer->pos = s->proxy->buffer->start;
+    s->proxy->buffer->last = s->proxy->buffer->start;
+}
+
+
 static void
 ngx_mail_proxy_dummy_handler(ngx_event_t *wev)
 {
@@ -743,16 +966,18 @@ ngx_mail_proxy_read_response(ngx_mail_se
         return NGX_AGAIN;
     }
 
-    if (*(b->last - 2) != CR || *(b->last - 1) != LF) {
-        if (b->last == b->end) {
-            *(b->last - 1) = '\0';
-            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,
-                          "upstream sent too long response line: \"%s\"",
-                          b->pos);
-            return NGX_ERROR;
-        }
+    if (s->protocol != NGX_MAIL_XMPP_PROTOCOL) {
+        if (*(b->last - 2) != CR || *(b->last - 1) != LF) {
+            if (b->last == b->end) {
+                *(b->last - 1) = '\0';
+                ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,
+                            "upstream sent too long response line: \"%s\"",
+                            b->pos);
+                return NGX_ERROR;
+            }
 
-        return NGX_AGAIN;
+            return NGX_AGAIN;
+        }
     }
 
     p = b->pos;
@@ -792,6 +1017,89 @@ ngx_mail_proxy_read_response(ngx_mail_se
         }
 
         break;
+
+    case NGX_MAIL_XMPP_PROTOCOL:
+        switch (state) {
+
+        case ngx_xmpp_stream:
+
+            while (p < b->last) {
+                if (b->last - p < 18) {
+                    b->pos = p;
+                    return NGX_AGAIN;
+                }
+
+                if (p[0]  == '<' &&
+                    p[1]  == '/' &&
+                    p[2]  == 's' &&
+                    p[3]  == 't' &&
+                    p[4]  == 'r' &&
+                    p[5]  == 'e' &&
+                    p[6]  == 'a' &&
+                    p[7]  == 'm' &&
+                    p[8]  == ':' &&
+                    p[9]  == 'f' &&
+                    p[10] == 'e' &&
+                    p[11] == 'a' &&
+                    p[12] == 't' &&
+                    p[13] == 'u' &&
+                    p[14] == 'r' &&
+                    p[15] == 'e' &&
+                    p[16] == 's' &&
+                    p[17] == '>') {
+                        b->pos = p;
+                        return NGX_OK;
+                }
+
+                p++;
+            }
+
+            b->pos = p;
+            return NGX_AGAIN;
+
+        case ngx_xmpp_auth_plain:
+
+            while (p < b->last) {
+                if (b->last - p < 8) {
+                    b->pos = p;
+                    return NGX_AGAIN;
+                }
+
+                if (p[0] == '<') {
+                    if (p[1] == 's' &&
+                        p[2] == 'u' &&
+                        p[3] == 'c' &&
+                        p[4] == 'c' &&
+                        p[5] == 'e' &&
+                        p[6] == 's' &&
+                        p[7] == 's') {
+                            b->pos = p;
+                            return NGX_OK;
+                    }
+
+                    if (p[1] == 'f' &&
+                        p[2] == 'a' &&
+                        p[3] == 'i' &&
+                        p[4] == 'l' &&
+                        p[5] == 'u' &&
+                        p[6] == 'r' &&
+                        p[7] == 'e') {
+                            b->pos = p;
+                            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,
+                                        "upstream auth failed: \"%s\"",
+                                        b->pos);
+                            return NGX_ERROR;
+                    }
+                }
+
+                p++;
+            }
+
+            b->pos = p;
+            return NGX_AGAIN;
+        }
+
+        break;
 
     default: /* NGX_MAIL_SMTP_PROTOCOL */
 
--- /dev/null
+++ nginx-1.10.1-10/src/mail/ngx_mail_xmpp_handler.c
@@ -0,0 +1,490 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+#include <ngx_mail.h>
+#include <ngx_mail_xmpp_module.h>
+
+
+static ngx_int_t ngx_mail_xmpp_stream(ngx_mail_session_t *s,
+    ngx_connection_t *c);
+static ngx_int_t ngx_mail_xmpp_starttls(ngx_mail_session_t *s,
+    ngx_connection_t *c);
+static ngx_int_t ngx_mail_xmpp_auth(ngx_mail_session_t *s,
+    ngx_connection_t *c);
+static void ngx_mail_xmpp_auth_fixup(ngx_mail_session_t *s,
+    ngx_connection_t *c);
+
+
+static u_char xmpp_stream_header_from[] =
+    "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
+    "<stream:stream version=\"1.0\" xmlns:stream=\"http://etherx.jabber.org/streams\" xmlns=\"jabber:client\" from=\"";
+static u_char xmpp_stream_header_id[] =
+    "\" id=\"";
+static u_char xmpp_stream_header_features[] =
+    "\"><stream:features>";
+static u_char xmpp_stream_feature_starttls[] =
+    "<starttls xmlns=\"urn:ietf:params:xml:ns:xmpp-tls\"/>";
+static u_char xmpp_stream_feature_starttls_required[] =
+    "<starttls xmlns=\"urn:ietf:params:xml:ns:xmpp-tls\"><required/></starttls>";
+static u_char xmpp_stream_feature_sasl_start[] =
+    "<mechanisms xmlns=\"urn:ietf:params:xml:ns:xmpp-sasl\">";
+static u_char xmpp_stream_feature_sasl_end[] =
+    "</mechanisms>";
+static u_char xmpp_stream_header_end[] =
+    "</stream:features>";
+
+#if (NGX_MAIL_SSL)
+static u_char xmpp_starttls_proceed[] =
+    "<proceed xmlns=\"urn:ietf:params:xml:ns:xmpp-tls\"/>";
+#endif
+
+static u_char  xmpp_auth_login_username_challenge[] =
+    "<challenge xmlns=\"urn:ietf:params:xml:ns:xmpp-sasl\">VXNlcm5hbWU6</challenge>";
+static u_char  xmpp_auth_login_password_challenge[] =
+    "<challenge xmlns=\"urn:ietf:params:xml:ns:xmpp-sasl\">UGFzc3dvcmQ6</challenge>";
+static u_char  xmpp_auth_plain_challenge[] =
+    "<challenge xmlns=\"urn:ietf:params:xml:ns:xmpp-sasl\"/>";
+
+#define XMPP_STREAM_UNDEFINED_CONDITION \
+    "<stream:error>" \
+    "<undefined-condition xmlns=\"urn:ietf:params:xml:ns:xmpp-streams\"/>" \
+    "</stream:error>"
+
+#define XMPP_STREAM_CLOSE \
+    "</stream:stream>"
+
+static u_char  xmpp_stream_close[] =
+    XMPP_STREAM_CLOSE;
+
+static u_char  xmpp_error_undefined_condition[] =
+    XMPP_STREAM_UNDEFINED_CONDITION
+    XMPP_STREAM_CLOSE;
+
+static u_char  xmpp_error_stream_undefined_condition[] =
+    "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
+    "<stream:stream version=\"1.0\" xmlns:stream=\"http://etherx.jabber.org/streams\">"
+    XMPP_STREAM_UNDEFINED_CONDITION
+    XMPP_STREAM_CLOSE;
+
+
+void
+ngx_mail_xmpp_init_session(ngx_mail_session_t *s, ngx_connection_t *c)
+{
+    ngx_mail_core_srv_conf_t  *cscf;
+
+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);
+
+    c->read->handler = ngx_mail_xmpp_init_protocol;
+
+    ngx_add_timer(c->read, cscf->timeout);
+
+    if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
+        ngx_mail_close_connection(c);
+    }
+
+    ngx_mail_send(c->write);
+}
+
+
+void
+ngx_mail_xmpp_init_protocol(ngx_event_t *rev)
+{
+    ngx_connection_t          *c;
+    ngx_mail_session_t        *s;
+    ngx_mail_xmpp_srv_conf_t  *iscf;
+
+    c = rev->data;
+
+    c->log->action = "in auth state";
+
+    if (rev->timedout) {
+        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, "client timed out");
+        c->timedout = 1;
+        ngx_mail_close_connection(c);
+        return;
+    }
+
+    s = c->data;
+
+    if (s->buffer == NULL) {
+        if (ngx_array_init(&s->args, c->pool, 2, sizeof(ngx_str_t))
+            == NGX_ERROR)
+        {
+            ngx_mail_session_internal_server_error(s);
+            return;
+        }
+
+        iscf = ngx_mail_get_module_srv_conf(s, ngx_mail_xmpp_module);
+
+        s->buffer = ngx_create_temp_buf(c->pool, iscf->client_buffer_size);
+        if (s->buffer == NULL) {
+            ngx_mail_session_internal_server_error(s);
+            return;
+        }
+    }
+
+    s->mail_state = ngx_xmpp_start;
+    c->read->handler = ngx_mail_xmpp_auth_state;
+
+    ngx_mail_xmpp_auth_state(rev);
+}
+
+
+void
+ngx_mail_xmpp_auth_state(ngx_event_t *rev)
+{
+    ngx_int_t            rc, do_close;
+    ngx_connection_t    *c;
+    ngx_mail_session_t  *s;
+
+    do_close = 0;
+
+    c = rev->data;
+    s = c->data;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, "xmpp auth state");
+
+    if (rev->timedout) {
+        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, "client timed out");
+        c->timedout = 1;
+        ngx_mail_close_connection(c);
+        return;
+    }
+
+    if (s->out.len) {
+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, "xmpp send handler busy");
+        s->blocked = 1;
+        return;
+    }
+
+    s->blocked = 0;
+
+    rc = ngx_mail_read_command(s, c);
+
+    if (rc == NGX_AGAIN || rc == NGX_ERROR) {
+        return;
+    }
+
+    s->text.len = 0;
+
+    if (rc == NGX_OK) {
+        ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0, "xmpp auth command: %i",
+                       s->command);
+
+        switch (s->mail_state) {
+
+        case ngx_xmpp_start:
+
+            switch (s->command) {
+
+            case NGX_XMPP_STREAM:
+                rc = ngx_mail_xmpp_stream(s, c);
+                break;
+
+            default:
+                rc = NGX_MAIL_PARSE_INVALID_COMMAND;
+                break;
+            }
+
+            break;
+
+        case ngx_xmpp_stream:
+
+            switch (s->command) {
+
+            case NGX_XMPP_STARTTLS:
+                rc = ngx_mail_xmpp_starttls(s, c);
+                break;
+
+            case NGX_XMPP_AUTH:
+                rc = ngx_mail_xmpp_auth(s, c);
+                break;
+
+            case NGX_XMPP_STREAM:
+                ngx_str_set(&s->out, xmpp_stream_close);
+                do_close = 1;
+                break;
+
+            default:
+                rc = NGX_MAIL_PARSE_INVALID_COMMAND;
+                break;
+
+            }
+
+            break;
+
+        case ngx_xmpp_auth_login_username:
+            rc = ngx_mail_auth_login_username(s, c, 0);
+
+            ngx_str_set(&s->out, xmpp_auth_login_password_challenge);
+            s->mail_state = ngx_xmpp_auth_login_password;
+
+            break;
+
+        case ngx_xmpp_auth_login_password:
+            rc = ngx_mail_auth_login_password(s, c);
+            break;
+
+        case ngx_xmpp_auth_plain:
+            rc = ngx_mail_auth_plain(s, c, 0);
+            break;
+
+        }
+    }
+
+    switch (rc) {
+
+    case NGX_DONE:
+        s->buffer->pos = s->buffer->last;
+
+        ngx_mail_xmpp_auth_fixup(s, c);
+        return;
+
+    case NGX_ERROR:
+        ngx_mail_session_internal_server_error(s);
+        return;
+
+    case NGX_MAIL_PARSE_INVALID_COMMAND:
+        s->state = 0;
+
+        if (s->mail_state == ngx_xmpp_start) {
+            ngx_str_set(&s->out, xmpp_error_stream_undefined_condition);
+        }
+        else {
+            ngx_str_set(&s->out, xmpp_error_undefined_condition);
+            s->mail_state = ngx_xmpp_start;
+        }
+        do_close = 1;
+        break;
+    }
+
+    s->args.nelts = 0;
+
+    if (s->buffer->pos == s->buffer->last) {
+        s->buffer->pos = s->buffer->start;
+        s->buffer->last = s->buffer->start;
+    }
+
+    ngx_mail_send(c->write);
+
+    if (do_close) {
+        ngx_mail_close_connection(c);
+    }
+}
+
+static ngx_int_t
+ngx_mail_xmpp_id(ngx_mail_session_t *s, ngx_connection_t *c)
+{
+    s->salt.data = ngx_pnalloc(c->pool,
+                               sizeof("18446744073709551616.") - 1
+                               + NGX_TIME_T_LEN);
+    if (s->salt.data == NULL) {
+        return NGX_ERROR;
+    }
+
+    s->salt.len = ngx_sprintf(s->salt.data, "%ul.%T",
+                              ngx_random(), ngx_time())
+                  - s->salt.data;
+
+    return NGX_OK;
+}
+
+static ngx_int_t
+ngx_mail_xmpp_stream(ngx_mail_session_t *s, ngx_connection_t *c)
+{
+    ngx_str_t *arg;
+    ngx_uint_t len;
+    u_char *p, *out;
+    ngx_uint_t starttls_on, starttls_only;
+    ngx_mail_xmpp_srv_conf_t *xscf;
+
+    if (s->mail_state != ngx_xmpp_start) {
+        return NGX_MAIL_PARSE_INVALID_COMMAND;
+    }
+
+    arg = s->args.elts;
+    if (s->args.nelts != 1 || arg[0].len == 0) {
+        return NGX_MAIL_PARSE_INVALID_COMMAND;
+    }
+
+    s->host.len = arg[0].len;
+    s->host.data = ngx_pnalloc(c->pool, s->host.len);
+    if (s->host.data == NULL) {
+        return NGX_ERROR;
+    }
+
+    ngx_memcpy(s->host.data, arg[0].data, s->host.len);
+
+    starttls_on = starttls_only = 0;
+
+#if (NGX_MAIL_SSL)
+    if (c->ssl == NULL) {
+        ngx_mail_ssl_conf_t  *sslcf;
+
+        sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);
+
+        if (sslcf->starttls == NGX_MAIL_STARTTLS_ON) {
+            starttls_on = 1;
+        }
+
+        if (sslcf->starttls == NGX_MAIL_STARTTLS_ONLY) {
+            starttls_only = 1;
+        }
+    }
+#endif
+
+    if (ngx_mail_xmpp_id(s, c) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    xscf = ngx_mail_get_module_srv_conf(s, ngx_mail_xmpp_module);
+
+    len = sizeof(xmpp_stream_header_from) - 1
+        + s->host.len
+        + sizeof(xmpp_stream_header_id) - 1
+        + sizeof(xmpp_stream_header_features) - 1
+        + sizeof(xmpp_stream_header_end) - 1
+        + s->salt.len;
+
+    if (starttls_on) {
+        len += sizeof(xmpp_stream_feature_starttls) - 1;
+    }
+    else if (starttls_only) {
+        len += sizeof(xmpp_stream_feature_starttls_required) - 1;
+    }
+    if (!starttls_only) {
+        len += sizeof(xmpp_stream_feature_sasl_start) - 1
+             + xscf->auth_mechanisms.len
+             + sizeof(xmpp_stream_feature_sasl_end) - 1;
+    }
+
+    out = p = ngx_pnalloc(c->pool, len + 1);
+    if (p == NULL) {
+        return NGX_ERROR;
+    }
+
+    p = ngx_cpymem(p, xmpp_stream_header_from, sizeof(xmpp_stream_header_from) - 1);
+    p = ngx_cpymem(p, s->host.data, s->host.len);
+    p = ngx_cpymem(p, xmpp_stream_header_id, sizeof(xmpp_stream_header_id) - 1);
+    p = ngx_cpymem(p, s->salt.data, s->salt.len);
+    p = ngx_cpymem(p, xmpp_stream_header_features, sizeof(xmpp_stream_header_features) - 1);
+    if (starttls_on) {
+        p = ngx_cpymem(p, xmpp_stream_feature_starttls, sizeof(xmpp_stream_feature_starttls) - 1);
+    }
+    else if (starttls_only) {
+        p = ngx_cpymem(p, xmpp_stream_feature_starttls_required, sizeof(xmpp_stream_feature_starttls_required) - 1);
+    }
+    if (!starttls_only) {
+        p = ngx_cpymem(p, xmpp_stream_feature_sasl_start, sizeof(xmpp_stream_feature_sasl_start) - 1);
+        p = ngx_cpymem(p, xscf->auth_mechanisms.data, xscf->auth_mechanisms.len);
+        p = ngx_cpymem(p, xmpp_stream_feature_sasl_end, sizeof(xmpp_stream_feature_sasl_end) - 1);
+    }
+    p = ngx_cpymem(p, xmpp_stream_header_end, sizeof(xmpp_stream_header_end) - 1);
+    *p = 0;
+
+    s->out.data = out;
+    s->out.len = len;
+
+    s->mail_state = ngx_xmpp_stream;
+
+    return NGX_OK;
+}
+
+static ngx_int_t
+ngx_mail_xmpp_starttls(ngx_mail_session_t *s, ngx_connection_t *c)
+{
+#if (NGX_MAIL_SSL)
+    ngx_mail_ssl_conf_t  *sslcf;
+
+    if (s->mail_state != ngx_xmpp_stream) {
+        return NGX_MAIL_PARSE_INVALID_COMMAND;
+    }
+
+    if (c->ssl == NULL) {
+        sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);
+        if (sslcf->starttls) {
+            c->read->handler = ngx_mail_starttls_handler;
+            ngx_str_set(&s->out, xmpp_starttls_proceed);
+            s->mail_state = ngx_xmpp_start;
+            return NGX_OK;
+        }
+    }
+#endif
+
+    return NGX_MAIL_PARSE_INVALID_COMMAND;
+}
+
+static ngx_int_t
+ngx_mail_xmpp_auth(ngx_mail_session_t *s, ngx_connection_t *c)
+{
+    ngx_int_t                  rc;
+
+#if (NGX_MAIL_SSL)
+    if (ngx_mail_starttls_only(s, c)) {
+        return NGX_MAIL_PARSE_INVALID_COMMAND;
+    }
+#endif
+
+    rc = ngx_mail_auth_parse(s, c);
+
+    switch (rc) {
+
+    case NGX_MAIL_AUTH_LOGIN:
+
+        ngx_str_set(&s->out, xmpp_auth_login_username_challenge);
+        s->mail_state = ngx_xmpp_auth_login_username;
+
+        return NGX_OK;
+
+    case NGX_MAIL_AUTH_LOGIN_USERNAME:
+
+        ngx_str_set(&s->out, xmpp_auth_login_password_challenge);
+        s->mail_state = ngx_xmpp_auth_login_password;
+
+        return ngx_mail_auth_login_username(s, c, 1);
+
+    case NGX_MAIL_AUTH_PLAIN:
+
+        ngx_str_set(&s->out, xmpp_auth_plain_challenge);
+        s->mail_state = ngx_xmpp_auth_plain;
+
+        return NGX_OK;
+
+    }
+
+    return rc;
+}
+
+void
+ngx_mail_xmpp_auth_fixup(ngx_mail_session_t *s, ngx_connection_t *c)
+{
+    u_char *p, *login;
+    size_t  len;
+
+    len = s->login.len + s->host.len + 1;
+
+    p = ngx_pnalloc(c->pool, len);
+    if (p == NULL) {
+        ngx_mail_session_internal_server_error(s);
+        return;
+    }
+
+    login = p;
+
+    p = ngx_cpymem(p, s->login.data, s->login.len);
+    *p++ = '@';
+    p = ngx_cpymem(p, s->host.data, s->host.len);
+
+    s->login.data = login;
+    s->login.len = len;
+    s->host.len = 0;
+
+    ngx_mail_auth(s, c);
+}
--- /dev/null
+++ nginx-1.10.1-10/src/mail/ngx_mail_xmpp_module.c
@@ -0,0 +1,192 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+#include <ngx_mail.h>
+#include <ngx_mail_xmpp_module.h>
+
+
+static void *ngx_mail_xmpp_create_srv_conf(ngx_conf_t *cf);
+static char *ngx_mail_xmpp_merge_srv_conf(ngx_conf_t *cf, void *parent,
+    void *child);
+
+
+static ngx_conf_bitmask_t  ngx_mail_xmpp_auth_methods[] = {
+    { ngx_string("plain"), NGX_MAIL_AUTH_PLAIN_ENABLED },
+    { ngx_string("login"), NGX_MAIL_AUTH_LOGIN_ENABLED },
+    { ngx_string("cram-md5"), NGX_MAIL_AUTH_CRAM_MD5_ENABLED },
+    { ngx_null_string, 0 }
+};
+
+
+static ngx_str_t  ngx_mail_xmpp_auth_methods_names[] = {
+    ngx_string("PLAIN"),
+    ngx_string("LOGIN"),
+    ngx_null_string,  /* APOP */
+    ngx_string("CRAM-MD5"),
+    ngx_null_string   /* NONE */
+};
+
+static u_char xmpp_mechanism_start[] =
+    "<mechanism>";
+static u_char xmpp_mechanism_end[] =
+    "</mechanism>";
+
+
+static ngx_mail_protocol_t  ngx_mail_xmpp_protocol = {
+    ngx_string("xmpp"),
+    { 5222, 5223 ,0, 0 },
+    NGX_MAIL_XMPP_PROTOCOL,
+
+    ngx_mail_xmpp_init_session,
+    ngx_mail_xmpp_init_protocol,
+    ngx_mail_xmpp_parse_command,
+    ngx_mail_xmpp_auth_state,
+
+    ngx_string(
+        "<stream:error>"
+        "<internal-server-error xmlns=\"urn:ietf:params:xml:ns:xmpp-streams\"/>"
+        "</stream:error>"
+        "</stream:stream>"
+    ),
+    ngx_string(
+        "<stream:error>"
+        "<policy-violation xmlns=\"urn:ietf:params:xml:ns:xmpp-streams\"/>"
+        "<text xmlns=\"urn:ietf:params:xml:ns:xmpp-streams\" xml:lang=\"en\">SSL certificate error</text>"
+        "</stream:error>"
+        "</stream:stream>"
+    ),
+    ngx_string(
+        "<stream:error>"
+        "<policy-violation xmlns=\"urn:ietf:params:xml:ns:xmpp-streams\"/>"
+        "<text xmlns=\"urn:ietf:params:xml:ns:xmpp-streams\" xml:lang=\"en\">No required SSL certificate</text>"
+        "</stream:error>"
+        "</stream:stream>"
+    )
+};
+
+
+static ngx_command_t  ngx_mail_xmpp_commands[] = {
+
+    { ngx_string("xmpp_client_buffer"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_xmpp_srv_conf_t, client_buffer_size),
+      NULL },
+
+    { ngx_string("xmpp_auth"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_1MORE,
+      ngx_conf_set_bitmask_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_xmpp_srv_conf_t, auth_methods),
+      &ngx_mail_xmpp_auth_methods },
+
+      ngx_null_command
+};
+
+
+static ngx_mail_module_t  ngx_mail_xmpp_module_ctx = {
+    &ngx_mail_xmpp_protocol,               /* protocol */
+
+    NULL,                                  /* create main configuration */
+    NULL,                                  /* init main configuration */
+
+    ngx_mail_xmpp_create_srv_conf,         /* create server configuration */
+    ngx_mail_xmpp_merge_srv_conf           /* merge server configuration */
+};
+
+
+ngx_module_t  ngx_mail_xmpp_module = {
+    NGX_MODULE_V1,
+    &ngx_mail_xmpp_module_ctx,             /* module context */
+    ngx_mail_xmpp_commands,                /* module directives */
+    NGX_MAIL_MODULE,                       /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    NULL,                                  /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    NULL,                                  /* exit process */
+    NULL,                                  /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static void *
+ngx_mail_xmpp_create_srv_conf(ngx_conf_t *cf)
+{
+    ngx_mail_xmpp_srv_conf_t  *xscf;
+
+    xscf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_xmpp_srv_conf_t));
+    if (xscf == NULL) {
+        return NULL;
+    }
+
+    xscf->client_buffer_size = NGX_CONF_UNSET_SIZE;
+
+    return xscf;
+}
+
+
+static char *
+ngx_mail_xmpp_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
+{
+    ngx_mail_xmpp_srv_conf_t *prev = parent;
+    ngx_mail_xmpp_srv_conf_t *conf = child;
+
+    u_char      *p;
+    size_t       size;
+    ngx_uint_t   i, m;
+
+    ngx_conf_merge_size_value(conf->client_buffer_size,
+                              prev->client_buffer_size,
+                              (size_t) ngx_pagesize);
+
+    ngx_conf_merge_bitmask_value(conf->auth_methods,
+                              prev->auth_methods,
+                              (NGX_CONF_BITMASK_SET
+                               |NGX_MAIL_AUTH_PLAIN_ENABLED
+                               |NGX_MAIL_AUTH_LOGIN_ENABLED));
+
+
+    size = 0;
+
+    for (m = NGX_MAIL_AUTH_PLAIN_ENABLED, i = 0;
+         m <= NGX_MAIL_AUTH_CRAM_MD5_ENABLED;
+         m <<= 1, i++)
+    {
+        if (m & conf->auth_methods) {
+            size += sizeof(xmpp_mechanism_start) - 1
+                  + ngx_mail_xmpp_auth_methods_names[i].len
+                  + sizeof(xmpp_mechanism_end) - 1;
+        }
+    }
+
+    p = ngx_pnalloc(cf->pool, size);
+    if (p == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    conf->auth_mechanisms.len = size;
+    conf->auth_mechanisms.data = p;
+
+    for (m = NGX_MAIL_AUTH_PLAIN_ENABLED, i = 0;
+         m <= NGX_MAIL_AUTH_CRAM_MD5_ENABLED;
+         m <<= 1, i++)
+    {
+        if (m & conf->auth_methods) {
+            p = ngx_cpymem(p, xmpp_mechanism_start, sizeof(xmpp_mechanism_start) - 1);
+            p = ngx_cpymem(p, ngx_mail_xmpp_auth_methods_names[i].data, ngx_mail_xmpp_auth_methods_names[i].len);
+            p = ngx_cpymem(p, xmpp_mechanism_end, sizeof(xmpp_mechanism_end) - 1);
+        }
+    }
+
+    return NGX_CONF_OK;
+}
--- /dev/null
+++ nginx-1.10.1-10/src/mail/ngx_mail_xmpp_module.h
@@ -0,0 +1,35 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#ifndef _NGX_MAIL_XMPP_MODULE_H_INCLUDED_
+#define _NGX_MAIL_XMPP_MODULE_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_mail.h>
+
+
+typedef struct {
+    size_t       client_buffer_size;
+
+    ngx_uint_t   auth_methods;
+    ngx_str_t    auth_mechanisms;
+} ngx_mail_xmpp_srv_conf_t;
+
+
+void ngx_mail_xmpp_init_session(ngx_mail_session_t *s, ngx_connection_t *c);
+void ngx_mail_xmpp_init_protocol(ngx_event_t *rev);
+void ngx_mail_xmpp_auth_state(ngx_event_t *rev);
+ngx_int_t ngx_mail_xmpp_parse_command(ngx_mail_session_t *s);
+
+
+extern ngx_module_t  ngx_mail_xmpp_module;
+
+
+#endif /* _NGX_MAIL_XMPP_MODULE_H_INCLUDED_ */
+
--- nginx-1.10.1-13.orig/auto/modules
+++ nginx-1.10.1-13/auto/modules
@@ -951,6 +951,15 @@ if [ $MAIL != NO ]; then
         . auto/module
     fi
 
+    if [ $MAIL_XMPP = YES ]; then
+        ngx_module_name="ngx_mail_xmpp_module"
+        ngx_module_deps="src/mail/ngx_mail_xmpp_module.h"
+        ngx_module_srcs="src/mail/ngx_mail_xmpp_module.c \
+                         src/mail/ngx_mail_xmpp_handler.c"
+
+        . auto/module
+    fi
+
     ngx_module_name=ngx_mail_auth_http_module
     ngx_module_deps=
     ngx_module_srcs=src/mail/ngx_mail_auth_http_module.c
--- nginx-1.10.1-13.orig/auto/options
+++ nginx-1.10.1-13/auto/options
@@ -112,6 +112,7 @@ MAIL_SSL=NO
 MAIL_POP3=YES
 MAIL_IMAP=YES
 MAIL_SMTP=YES
+MAIL_XMPP=YES
 
 STREAM=NO
 STREAM_SSL=NO
@@ -297,6 +298,7 @@ use the \"--with-mail_ssl_module\" optio
         --without-mail_pop3_module)      MAIL_POP3=NO               ;;
         --without-mail_imap_module)      MAIL_IMAP=NO               ;;
         --without-mail_smtp_module)      MAIL_SMTP=NO               ;;
+        --without-mail_xmpp_module)      MAIL_XMPP=NO               ;;
 
         --with-stream)                   STREAM=YES                 ;;
         --with-stream=dynamic)           STREAM=DYNAMIC             ;;
@@ -472,8 +474,8 @@ cat << END
   --without-http                     disable HTTP server
   --without-http-cache               disable HTTP cache
 
-  --with-mail                        enable POP3/IMAP4/SMTP proxy module
-  --with-mail=dynamic                enable dynamic POP3/IMAP4/SMTP proxy module
+  --with-mail                        enable POP3/IMAP4/SMTP/XMPP proxy module
+  --with-mail=dynamic                enable dynamic POP3/IMAP4/SMTP/XMPP proxy module
   --with-mail_ssl_module             enable ngx_mail_ssl_module
   --without-mail_pop3_module         disable ngx_mail_pop3_module
   --without-mail_imap_module         disable ngx_mail_imap_module
